
# Enumeration & Brute Force 

## Authentication Enumeration 

Authentication enumeration involves observing how an application responds during authentication-related actions to identify valid usernames and understand underlying security behavior.

**Username Identification:**  
Different error messages during login or password reset (e.g., _"username doesn’t exist"_ vs _"incorrect password"_) reveal whether a username is valid. Registration pages that say _"username/email already taken"_ also confirm existing accounts.

**Password Policies:**  
Error messages that disclose password requirements (e.g., regex patterns requiring uppercase letters, digits, and symbols) allow attackers to craft dictionaries that match the enforced policy, making password guessing more effective.

**Common Enumeration Points:**

- **Registration pages:** Check if a username or email already exists.
- **Password reset pages:** Response differences confirm valid accounts.
- **Verbose error messages:** Reveal account validity.
- **Breached credential data:** Previously leaked usernames/passwords can be tested on other platforms.

Q: What type of error messages can unintentionally provide attackers with confirmation of valid usernames ? 
A: Verbose errors 

## Enumerating Users via Verbose Errors 


Verbose errors are detailed failure messages that reveal internal implementation details of an application (file paths, DB schema, user data). Useful for debugging but dangerous if exposed to attackers.

**What verbose errors can disclose:**

- **Internal paths:** server file paths and directory structure.
- **Database details:** table/column names or SQL error text.
- **User information:** hints about usernames or account state.
    

**How attackers induce verbose errors (common techniques):**

- **Invalid login attempts:** different error wording/timing that distinguishes valid vs invalid usernames.
- **SQL injection:** injecting SQL (e.g., a single quote) to force DB errors that reveal schema or queries.
- **File inclusion / path traversal:** payloads like `../../` to trigger path-related errors exposing internal locations.
- **Form manipulation:** tampering with fields (including hidden ones) to cause validation or logic errors that reveal backend expectations.
- **Application fuzzing:** automated, varied inputs (e.g., via Burp Intruder) to find inputs that provoke informative failures.

**Connection to enumeration & brute force:**

- Verbose errors help confirm valid usernames (enumeration).
- They reveal password-policy and lockout behavior details that make brute-force and credential-stuffing attacks more effective.

Q: What is the valid email address from the list ? 
A: canderson@gmail.com

## Exploiting Vulnerable Password Rest Logic 

Password reset flows enable users to regain account access via channels (email, SMS, or security questions). Implementation must protect the secrecy and integrity of reset tokens and the identity-verification process.

**Common Methods:**

- **Email-based reset:** sends a link or token to the registered email; relies on email account security and token secrecy.
- **Security-question reset:** validates pre-configured answers; relies on secrecy of PII and answer strength.
- **SMS-based reset:** sends a code or link via SMS; relies on handset/SIM security and confidentiality of the message.
    

**Key Vulnerabilities:**

- **Predictable tokens:** sequential or guessable tokens enable attackers to generate valid reset links.
- **Token expiration issues:** long-lived or non-expiring tokens enlarge the attack window; tokens must be single-use and short-lived.
- **Insufficient validation:** weak security questions or compromised recovery channels allow unauthorized resets.
- **Information disclosure:** responses that reveal whether an email/username is registered aid enumeration.
- **Insecure transport:** delivering tokens over non-HTTPS or intercepted channels exposes reset secrets.

Q: What is the flag ? 
A: THM{50_pr3d1ct4BL333!!}

## Exploiting HTTP Basic Authentication 

Basic Authentication is a simple authentication mechanism where a client sends a username and password to the server using the HTTP `Authorization` header. The credentials are formatted as `username:password` and **base64 encoded**, not encrypted.

**Header Format:**

```
Authorization: Basic <base64(username:password)>
```

**Use Cases:**

- Still commonly used on **network devices** (e.g., routers, IoT devices) where resources are limited.
- Suitable for environments where **session management is unnecessary** and access is infrequent (e.g., configuration interfaces).

**Defined In:**

- **RFC 7617** — HTTP Basic Authentication specification.

**Security Considerations:**

- **Base64 ≠ Encryption** — credentials can be easily decoded.
- Must be used **only over HTTPS** to prevent interception.
- **Weak passwords** can be brute-forced.
- Provides **no session handling or additional security features** (unlike OAuth or token-based systems).

Q: What is the flag ? 
A: THM{b4\$$1C_AuTTHHH} 


## OSINT 

**Wayback URLs (Internet Archive)**

- The Wayback Machine (archive.org/web) archives historical versions of sites.
- Inspecting archived pages can reveal files, directories or content removed from the live site but still accessible or referenced, which may expose sensitive remnants useful to an attacker.

**Google Dorks (targeted search queries)**

- Crafting targeted search queries (Google Dorks) uncovers information not intended to be public: admin panels, backup folders, logs, etc.
- Example queries from the provided text:
    
    - `site:example.com inurl:admin` — find administrative panels.
    - `filetype:log "password" site:example.com` — locate log files containing passwords.
    - `intitle:"index of" "backup" site:example.com` — discover backup directories or exposed indexes.

# Session Management 

## What is Session Management ? 

Web applications use sessions to maintain a user's identity across multiple requests because HTTP is stateless.

**Session Lifecycle:**

- **Session Creation:** A session is often created when visiting the site and is definitely established after login. The user receives a session ID which must be securely generated and stored.

- **Session Tracking:** The session ID is sent with each request so the server can identify the user and their permissions. Weak session tracking can lead to session hijacking or impersonation.
    
- **Session Expiry:** Sessions should expire after a set period of inactivity. Expired session IDs must no longer be accepted to prevent unauthorized reuse.
    
- **Session Termination:** When a user logs out, the session must be fully invalidated even if it has not expired. Incorrect termination can allow continued access.

Q: Which state in the session management lifecycle deals with user's pressing the logout button ?
A: Session Termination 

Q: Which state in the session management lifecycle deals with user's providing their credentials ?
A: Session Creation 

Q: Which state in the session management lifecycle deals with user's actions performed after authentication ? 
A: Session Tracking

Q: Which state in the session management lifecycle deals with user's that forget to log out of the application ? 
A: Session Expiry 

## IAAA Model 

The IAAA model explains the key concepts involved in secure user access:

- **Identification:** The user claims an identity, usually by providing a username.

- **Authentication:** The user proves the claimed identity, typically by supplying a correct password. Successful authentication leads to **session creation**.
    
- **Authorisation:** Determines what the authenticated user is allowed to do. During **session tracking**, the server checks the session to verify the user’s permissions for each action.
    
- **Accountability:** Actions performed by a user should be logged along with the session ID to trace activities during investigations or incidents.

In session management:

- Authentication ensures sessions are created securely.
    
- Authorization ensures the session holder has the correct permissions.
    
- Accountability ensures actions can be traced back to a session in case of misuse.

Q: What is the name of the process in the IAAA model that would be responsible for tracking your actions and logging them ? 
A: Accountability 

Q: What is the name of the process in the IAAA model that would be responsible for granting you a session value ? 
A: Authentication 

Q: What is the name of the process in the IAAA model that would be responsible for verifying that you have the relevant permissions to perform an action ? 
A: Authorization 

## Cookies vs Tokens 

Web applications typically manage sessions in one of two ways: **cookies** or **tokens**.

**Cookie-Based Session Management**

- The server sends a session ID via a `Set-Cookie` header (e.g., `Set-Cookie: session=12345;`).
    
- The browser stores and **automatically sends** the cookie with each request.
    
- Common cookie security attributes:
    
    - **Secure** – send only over HTTPS.
        
    - **HttpOnly** – prevents JavaScript from reading the cookie.
        
    - **Expire / Max-Age** – controls session lifetime.
        
    - **SameSite** – helps prevent CSRF.
        
- **Benefit:** Built-in browser handling and security features.
    
- **Drawback:** Cookies can be affected by CSRF since they are sent automatically.
    

**Token-Based Session Management**

- After login, the server sends a **token** (e.g., a JWT).
    
- The client stores it manually (often in LocalStorage).
    
- Client-side code adds the token to the **Authorization** header:
	```
	Authorization: Bearer <token>
	```
- **Benefit:** Not automatically sent → protects against CSRF and works well in distributed apps.
    
- **Drawback:** No automatic security protections; tokens must be carefully protected from exposure (e.g., XSS risk).

Q: What cookie attribute can be used to ensure that the cookie is only transmitted via secure HTTP channels ? 
A: secure 

Q: What HTTP header is used in the response to inform the browser that a cookie being sent ? 
A: Set-Cookie 

Q: What HTTP header is often used in requests to indicate the transmission of a JWT ? 
A: Authorization: Bearer 

## Securing the Session Lifecycle 

Q: What phase of the session management lifecycle would be vulnerable if you could predict what the value of a session would be ? 
A: Session creation 

Q: What phase of the session management lifecycle would be vulnerable if you don't have the ability to flush a threat actor's access to your session ? 
A: session termination 

Q: What phase of the session management lifecycle would be vulnerable if there wasn't sufficient information to piece together what happened during an incident ?
A: session tracking 

Q: What phase of the session management lifecycle would be vulnerable if the session value itself was transmitted through an insecure redirect ? 
A: session creation 

## Exploiting Insecure Session Management (Practical)

Q: What is the username of the student with the name X  ?
A: THM{Got.The.User}

Q: How many lecturers are registered on the application ?
A: 1

Q: Excluding the unauthenticated user, how many roles does the application have ? 
A: 3 

Q: How many test attempts in total have been performed on the application ? 
A: 4 

Q: What is the highest score that student1 has achieved on a test ?
A: 3 

Q: What is the sequence of correct answers for the Database Types test ? (Format y=yes and n =no, separated by commas) ? 
A: y, n, n

# JWT Security 

## Token - Based Authentication 

APIs often use **token-based session management** instead of cookies because tokens work consistently across different clients (web, mobile, desktop). After login, the server issues a **token** (commonly a **JWT**) that the client stores (e.g., in LocalStorage) and sends with each request using:

```
Authorization: Bearer <token>
```

Unlike cookies, tokens are not automatically handled by the browser — **client-side code must attach them manually**. This makes tokens well-suited for API-driven applications, but also means the application must securely manage storage, transmission, and verification of the token, since fewer automatic security protections exist compared to cookies.

Q; What is the common header used to transport the JWT in a request ? 
A: Authorization: Bearer 

## JSON Web Tokens 

A **JWT (JSON Web Token)** is made up of three **Base64URL-encoded** parts separated by dots:
```
header.payload.signature
```

- **Header:** Specifies the token type (JWT) and the **signing algorithm**.
    
- **Payload:** Contains **claims** (information about the user or session). Claims can be standard or custom.
    
- **Signature:** Ensures the token is **authentic** and **untampered**. Created using the algorithm defined in the header.
    

**Signing Algorithms:**

- **None:** No signature — **not secure**.
    
- **Symmetric (e.g., HS256):** The same **secret key** is used to sign and verify the token.
    
- **Asymmetric (e.g., RS256):** Signed with a **private key** and verified with the **public key**.
    

**Key Security Idea:**  
The **signature** allows any trusted service to verify that the JWT is valid and has not been modified, enabling secure central authentication across multiple applications.

Q: HS256 is an example of what type of signing algorithm ? 
A: Symmetric 

Q: RS256 is an example of what type of signing algorithm ? 
A: Asymmetric 

Q: What is the name use for encrypted JWTs ? 
A: JWE

## Sensitive Information Disclosure 

Unlike traditional server-side sessions, **JWT payloads are stored and sent on the client**, meaning all claims inside the token are **visible** to the user. If developers place sensitive data in the payload (e.g., password hashes, clear-text passwords, internal server details), this information can be easily extracted since JWTs are only **Base64URL encoded**, not encrypted.

**Key Risk:**  
If sensitive values are placed in JWT claims, attackers can decode the token and **directly obtain confidential data.**

You can **decode** the **JWT token** on  [jwt.io](jwt.io) 

**Safe Practice:**  
Only store **non-sensitive, minimal identity information** in the JWT payload, and keep confidential data **server-side**.

Q: What is the flag for example 1? 
A: THM{9cc039cc-d85f-45d1-ac3b-818c8383a560}

## Signature Validation Mistakes 

**Problem:** Incorrect or missing JWT signature checks let attackers forge tokens and escalate privileges.

**Common mistakes**

- **No signature verification** — `verify_signature=False` or skipped checks allow any modified token to be accepted.
    
- **`alg: "none"` downgrade** — accepting `none` lets attackers remove the signature and still pass verification.
    
- **Weak symmetric secrets** — short/common secrets can be cracked offline, allowing signature forging.

```bash
hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list
```
    
- **Algorithm confusion (HS ↔ RS)** — accepting both symmetric and asymmetric algs and using the wrong key lets an attacker sign with a public key as an HMAC secret.

```python
import jwt

public_key = "ADD_KEY_HERE"

payload = {
    'username' : 'user',
    'admin' : 0
}

access_token = jwt.encode(payload, public_key, algorithm="HS256")
print (access_token)
```

Q: what is the flag for example 2 ? 
A: THM{6e32dca9-0d10-4156-a2d9-5e5c7000648a}

Q: What is the flag for example 3 ? 
A: THM{6e32dca9-0d10-4156-a2d9-5e5c7000648a}

Q: What is the flag for example 4 ?
A: THM{e1679fef-df56-41cc-85e9-af1e0e12981b}

Q: What is the flag for example 5 ? 
A: THM{f592dfe2-ec65-4514-a135-70ba358f22c4}

## JWT Lifetimes

Tokens must have appropriate lifetimes so a stolen token has only a small window of misuse. JWTs encode lifetime in the `exp` (and optionally `nbf`/`iat`) claims — but unlike server-side sessions, JWTs cannot be forcibly expired by the issuer unless additional mechanisms are used.

**Common problems**

- **Missing or excessively long `exp`:** tokens remain valid too long (or forever).
    
- **No revocation mechanism:** JWTs cannot be invalidated server-side without extra state (breaks decentralisation).
    
- **Reuse after logout/password change:** long-lived tokens remain valid after user action unless revoked.

Q: What is the flag for example 6 ? 
A: THM{a450ae48-7226-4633-a63d-38a625368669}

## Cross-Service Relay Attacks 

The JWT `aud` (audience) claim indicates which application(s) a token is intended for. In multi-app environments with a central auth server, `aud` is used to prevent tokens issued for one service being accepted by another.

**The risk (Cross-Service Relay)**  
If a service does **not** enforce `aud`, a token validly signed for App A (which may include privileged claims like `"admin": true`) can be presented to App B. App B may trust the token after signature verification and mistakenly grant privileges — a Cross-Service Relay / privilege escalation.

**Why it happens**

- Verification of `aud` is omitted or inconsistent (checked at auth server only).
    
- Services trust signature validity alone without checking intended audience or scope.
    
- Shared claims (role/admin flags) are reused across services without scoping.
    

**Impact**

- Horizontal or vertical privilege escalation across services.
    
- Unauthorized access to admin functions or sensitive data on other applications.
    

**Detection signals**

- Tokens accepted by multiple services despite different intended roles.
    
- Audit logs showing token use on an unexpected service (`aud` mismatch in received tokens).
    
- Unexpected privilege checks passing after cross-service requests.

Q: What is the flag for example 7  ?
A: THM{f0d34fe1-2ba1-44d4-bae7-99bd555a4128}

## Conclusion 


In this room, several common misconfigurations and vulnerabilities with JWT implementations were showcased. As a summary, take note of the following:

- As JWTs are sent client-side and encoded, sensitive information should not be stored in their claims.
- The JWT is only as secure as its signature. Care should be taken when verifying the signature to ensure that there is no confusion or weak secrets being used.
- JWTs should expire and have sensible lifetimes to avoid persistent JWTs being used by a threat actor.
- In SSO environments, the audience claim is crucial to ensure that the specific application's JWT is only used on that application.
- As JWTs make use of cryptography to generate the signature, cryptographic attacks can also be relevant for JWT exploitation. We will dive into this a bit more in our cryptography module.

# OAuth Vulnerabilities

